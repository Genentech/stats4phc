stages:
  - build
  - deploy


# Rules

.rule-is-head: &rule-is-head
  - if: '$CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH'
    when: never



# Templates

.r-environment:
  image: rocker/verse:4.2.2
  tags:
    - on-prem
    - x86_64
    - linux
    - docker

.cached-user-library:
  before_script:
    # use job credentials when pulling repo from same gitlab instance
    - git config --global url."${CI_SERVER_PROTOCOL}://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}".insteadOf "${CI_SERVER_PROTOCOL}://${CI_SERVER_HOST}"

    # avoid build impact of storing cache in repo project directory
    - echo '' >> .Rbuildignore  # ensure we append a newline
    - echo '^\.gitlab-cache' >> .Rbuildignore
    - cat .Rbuildignore

    # update our lib paths to make use of the cache
    # use R_REPOS envvar when deciding where finding installation source
    - |
      echo '
      # use gitlab-cache as primary package library
      .libPaths(c(file.path(getwd(), ".gitlab-cache", "user-library"), .libPaths()))
      options(
        keep.source.pkgs = TRUE,
        repos = if (nchar(Sys.getenv("R_REPOS", unset = "")) > 0L) {
            eval(parse(text = Sys.getenv("R_REPOS")))
          } else {
            getOption("repos")
          })' >> $(R RHOME)/etc/Rprofile.site
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .gitlab-cache/user-library


build-package:
  stage: build
  extends:
    - .r-environment
    - .cached-user-library
  script:
    - |
      if [ "" == "$LANG" ]; then export LANG="en_US.UTF-8"; echo "LANG=$LANG"; fi
      echo -e "\e[0Ksection_start:`date +%s`:r_cmd_build[collapsed=true]\r\e[0KR CMD build"
      R CMD build .
      echo -e "\e[0Ksection_end:`date +%s`:r_cmd_build\r\e[0K"
  artifacts:
    expire_in: 1 day
    paths:
      - stats4phc_*.tar.gz


OCEAN RSPM Deploy:
  needs: ["build-package"]
  image: "${image_address}"
  stage: deploy
  rules:
    - *rule-is-head
    - when: always
  script:
    - |
      PKG_NAME=$(grep "Package:" DESCRIPTION | awk -F ": " '{print $NF}')
      PKG_TARBALL=$(echo $PKG_NAME_*.tar.gz)
      echo "Deploying to RSPM PROD"
      export PACKAGEMANAGER_TOKEN=$PACKAGEMANAGER_TOKEN_PROD
      export PACKAGEMANAGER_ADDRESS=$PACKAGEMANAGER_ADDRESS_PROD
      echo "Downloading the RSPM client binary"
      curl -fOJH "Authorization: Bearer ${PACKAGEMANAGER_TOKEN}" ${PACKAGEMANAGER_ADDRESS}/__api__/download
      echo "Making client binary executable"
      chmod +x ./rspm
      echo "Pushing $PKG_TARBALL file to ${PACKAGEMANAGER_ADDRESS} on the Non-Validated repository"
      ./rspm add --replace --source=Non-Validated --path=${PKG_TARBALL}

